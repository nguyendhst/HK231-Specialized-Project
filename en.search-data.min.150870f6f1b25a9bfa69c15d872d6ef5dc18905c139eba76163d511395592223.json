[{"id":0,"href":"HK231-Specialized-Project/introduction/","title":"Introduction","section":"","content":" Introduction # Background and motivation for the project Problem statement and objectives Overview of the low-code platform and its significance in supporting the development of a promotion platform Background and Motivation # Problem Statement and Objectives # Overview of the Low-Code Platform # "},{"id":1,"href":"HK231-Specialized-Project/literature-review/","title":"Literature Review","section":"","content":" Literature Review # Review of existing low-code platforms and their features Exploration of related technologies and frameworks Analysis of similar projects or research in the field "},{"id":2,"href":"HK231-Specialized-Project/methodology/","title":"Methodology","section":"","content":" Methodology # Description of the development methodology employed Overview of the technologies, tools, and frameworks used Development Methodology # Development Approach Task Management Version Control Developement Approach # The project\u0026rsquo;s development approach is based on the Agile methodology, but does not follow strictly to any existing framework. Some of the main principles of the Agile methodology that will be followed are:\nEach team member shares the same responsibilities and has the same authority. The team is self-organizing and self-managing. The team is cross-functional and has all the skills necessary to complete the project. The team is self-sufficient and does not rely on external resources. The project will be divided into multiple iterations, which will have a duration of 1 week. Each iteration will have a set of tasks to be completed, and at the end of each iteration, the team will deliver a working product increment. The product increment will be reviewed and evaluated by the team and the advisors, and the feedback will be used to improve the product in the next iteration.\nTask Management # Task management is done using GitHub Projects. The project is divided into multiple iterations, each of which is represented by a GitHub Project board. Each iteration board is divided into 4 columns: To do, In progress, Review, and Done. Each task is represented by a GitHub Issue, which is then added to the corresponding column on the board. The team members will then move the tasks between the columns as they progress through the iteration.\nVersion Control # Version control of the project is done using Git and GitHub. The project repository is hosted on GitHub and is accessible at link.\nTo work on the project, a Git branching model convention is used. The model is as follows:\n%%{init: { 'logLevel': 'debug', 'theme': 'base', 'gitGraph': {'showBranches': true, 'showCommitLabel':true,'mainBranchOrder': 1}} }%% gitGraph LR: commit branch dev order: 1 branch feature/1 order: 2 commit commit checkout dev merge feature/1 checkout main branch feature/2 order: 3 commit commit merge feature/1 checkout dev merge feature/2 checkout main merge dev branch hotfix order: 0 commit commit checkout main merge hotfix Main branch: main - The main branch is the branch where the source code of HEAD always reflects a production-ready state.\nDevelopment branch: dev - The development branch is the branch where the source code of HEAD always reflects a state with the latest delivered development changes for the next release. Some would call this the “integration branch”. This is where any automatic nightly builds are built from.\nFeature branch: feature/1 - Feature branches (or sometimes called topic branches) are used to develop new features for the upcoming or a distant future release. When starting development of a feature, the target release in which this feature will be incorporated may well be unknown at that point. The essence of a feature branch is that it exists as long as the feature is in development, but will eventually be merged back into develop (to definitely add the new feature to the upcoming release) or discarded (in case of a disappointing experiment).\nHotfix branch: hotfix - Hotfix branches are very much like release branches in that they are also meant to prepare for a new production release, albeit unplanned. They arise from the necessity to act immediately upon an undesired state of a live production version. When a critical bug in a production version must be resolved immediately, a hotfix branch may be branched off from the corresponding tag on the master branch that marks the production version.\nTechnologies, Tools, and Frameworks # "},{"id":3,"href":"HK231-Specialized-Project/project-management/","title":"Project Management","section":"","content":" Project Management # Overview of project planning and scheduling Discussion of project milestones and deliverables Reflection on team collaboration and coordination Lessons learned and recommendations for future projects Project Planning and Scheduling # Project Timeline # The project begins from 11/09/2023 and is expect to lasts 15 weeks until 19/12/2023. The project is divided into 3 phases, each of which lasts 5 weeks. The phases are as follows:\nPhase 1: Requirement Analysis Phase 2: System Design Phase 3: Implementation Phase 4: Testing and Deployment Two major milestones are set for the project:\nFirst release: 01/10/2023 MVP release: 11/12/2023 gantt dateFormat YYYY-MM-DD title Project Timeline axisFormat %m/%d section Requirement Analysis Requirement Analysis: 2023-08-28, 2023-09-11 section System Design System Design: 2023-09-11, 2023-09-18 section Implementation Implementation: 2023-09-18, 2023-12-10 section Testing and Deployment Testing and Deployment: 2023-12-10, 2023-12-17 Project Milestones and Deliverables # Team Collaboration and Coordination # Lessons Learned and Recommendations # "},{"id":4,"href":"HK231-Specialized-Project/requirement-analysis/","title":"Requirement Analysis","section":"","content":" Requirement Analysis # Identification and documentation of functional and non-functional requirements Use cases and user stories for the low-code platform Discussion of expectations and limitations of the project "},{"id":5,"href":"HK231-Specialized-Project/system-design/","title":"System Design","section":"","content":" System Design # High-level architecture of the low-code platform Explanation of the chosen architectural style Description of the key components and their interactions Detailed design of each microservice and its responsibilities Data model design and database schema High-Level Architecture # Activity Diagram # Architectural Style # Arcchitecture style is the fundamental structural design of a software system. It consists of a set of patterns and principles used to define the system\u0026rsquo;s components, their interactions, and the constraints that guide their design and evolution. 1\nComparison of architectural styles # Layered Architecture\nThe layered architecture style is a hierarchical design pattern often used in software applications. It breaks apart the application into different functional layers, each providing services to the layer above it 2.\nAdvantages:\nHigh level of abstraction which simplifies development and maintenance. Changes in one layer have minimal impact on other layers, promoting isolation and reducing dependencies. Promotes separation of concerns, where each layer focuses on a specific function 3. Disadvantages:\nOverhead and potential performance degradation due to the need for data to pass through multiple layers. The design can be rigid and may not be suitable for applications requiring high levels of scalability or flexibility. Can lead to \u0026ldquo;fat\u0026rdquo; layers if not carefully managed, where a layer takes on too many responsibilities 4. Pipeline Architecture\nPipeline architecture is a design pattern where data flows through several stages or steps to complete a process. Each stage operates concurrently, and the output of one stage is the input to the next.\nAdvantages:\nEfficient for large volumes of data and complex processing tasks, as data moves through stages concurrently. Each stage is independent and can be modified or replaced without affecting others. Enables high throughput and processing speed, especially in systems with parallel processing capabilities. Disadvantages:\nCan be complex to design and manage, particularly for complex tasks requiring many stages. Performance is limited by the slowest stage in the pipeline. If a stage fails, it can disrupt the entire process. Microkernel Architecture\nMicrokernel architecture is a design pattern where the kernel (core of the operating system) provides only basic services such as inter-process communication, basic scheduling, and basic I/O handling. All other services run as independent processes in user space, communicating with the kernel and each other as necessary 5, 6.\nAdvantages:\nEnhances the reliability and security of the system. If a user-level process fails, it does not affect the kernel or other processes 7. Enables modularity and flexibility, as services can be added, removed or replaced without affecting the kernel 8. Disadvantages:\nPerformance can be slower due to the overhead of inter-process communication. The design can lead to increased complexity, making it more challenging to develop and maintain 9. Service-Based Architecture\nA Service-Based Architecture (SBA) is a type of architecture where services are the primary architectural components. The services are built on the concept of sharing as much as possible. For example, in a large retail company that has many applications associated with the processing of an order, SOA tries to address this problem through enterprise-level shared services (enterprise services). The Order service is smart enough to know which database to go to retrieve and update order data for each system, at the same time synchronizing the data among all three systems 1.\nAdvantages\nComponent Sharing: SBA promotes the sharing of components across the enterprise, increasing scalability and efficiency 1. Service Availability and Responsiveness: SBA addresses service availability (the ability of a remote service to accept requests in a timely manner) and service responsiveness (the ability of the service consumer to receive a timely response from the service) 1. Disadvantages\nComplexity: SBA can be complex and might not be needed for all types of applications. It might be a good choice for larger, more diverse environments but less so for smaller environments like web and mobile applications 1. Coordination: There might be a need for coordination among services to fulfill a single business request, which can increase development, testing, deployment, and maintenance time 1. Event-Driven Architecture\nEvent-Driven Architecture (EDA) uses a publish-subscribe (pub-sub) model, where producers publish events, and consumers subscribe to them. The producers are independent of the consumers, and consumers are independent of each other. It is useful when different subsystems must perform different types of processing on the same event data 1.\nAdvantages\nDecoupling: In EDA, the producers and consumers are decoupled, which allows them to be scaled, updated, and deployed independently 1. Fault Tolerance: Since services are decoupled from each other in EDA, faults are isolated to individual services. If a subscribing service fails, it doesn\u0026rsquo;t impact the service that sent the event. Communications are queued in a broker until the subscriber is repaired or replaced 1. Real-Time Processing and Responsiveness: EDA enables real-time processing and responsiveness by reacting to events as they occur. It ensures that the system can respond quickly to changes, enabling faster decision-making, real-time analytics, and immediate action 1. Disadvantages\nDifficulties with Monitoring: Since the services are independent of each other, you need a proper design to understand how they interact with each other and also a proper alerting mechanism to understand the knock-on effect should a service fail 1 Complexity: EDA can be complex to implement and manage. It requires a different programming model that may be unfamiliar to developers who are used to request-response models 1. Space-Based Architecture\nSpace-Based Architecture (SBA) is a software design approach that organizes the system around the concept of \u0026ldquo;spaces\u0026rdquo;, which are essentially isolated and autonomous units of functionality. Each space has its own data, logic, and interface, and they communicate with each other through message passing1.\nAdvantages\nIsolation and Autonomy: SBA promotes a high degree of isolation and autonomy, making it easier to test, deploy, and evolve the system. Since each space is independent, it can be developed, tested, and deployed separately, allowing developers to work on different spaces concurrently 1. Scalability and Performance: SBA allows for easy handling of scalability and performance. Because each space is isolated and can be scaled separately, it allows for better control of the resources used by the system 1. Disadvantages\nComplexity: SBA requires careful planning and coordination and can add complexity to the system. This complexity can increase the difficulty of development and maintenance 1. Microservices Architecture\nA Microservices Architecture is an architectural method that relies on a series of independently deployable services. These services have their own business logic and database with a specific goal. Updating, testing, deployment, and scaling occur within each service. Microservices don\u0026rsquo;t reduce complexity, but they make any complexity visible and more manageable by separating tasks into smaller processes that function independently of each other 1.\nAdvantages\nIndependent Deployment: Microservices can be deployed independently, allowing developers to update or fix issues in one service without affecting the others 1. Scalability: Each microservice can be scaled independently based on its specific needs, which leads to better resource utilization 1. Technology Diversity: In a microservices architecture, each service can be built using the technology stack that best suits its requirements. This allows developers to choose the most suitable technologies for each service 1. Disadvantages\nIncreased Complexity: Microservices can add increased complexity that leads to development sprawl, or rapid and unmanaged growth. It can be challenging to determine how different components relate to each other 1. Debugging Challenges: Each microservice has its own set of logs, which makes debugging more complicated. A single business process can run across multiple machines, further complicating debugging 1. Chosen architectural style # For a low-code platform that includes a web-based user interface for modeling applications, defining business logic, and deploying web applications. There are several prolems that need to be addressed:\nPerformance: The platform should be able to handle a large number of users and applications. Scalability: The platform should be able to scale up and down based on demand since a common runtime environment is used for all applications. Many core functionalities: Data Management Business Logic Execution Application Deployment Using a microservices architecture, we can address these problems by breaking down the platform into smaller, more manageable services. Each service can be developed, tested, and deployed independently, allowing for better control of the resources used by the system. This also allows for easier handling of scalability and performance, as each service can be scaled separately.\nHowever, this can add more complexity to the development process:\nCommunication between services can be challenging to manage. It can be challenging to determine how different components relate to each other. Each microservice has its own set of logs, which makes debugging more complicated. Instead, to better manage the complexity of the system, we can use a modular monolith architecture. This architecture allows us to break down the system into smaller modules, each responsible for a specific feature or functionality. These modules can be developed, tested, and deployed independently, allowing for better control of the resources used by the system. This also allows for easier handling of scalability and performance, as each module can be scaled separately.\nModular Monolith Architecture:10\nImplement the server-side application as a single unit (monolith), but the codebase is organized into several modules. Each module is responsible for a specific feature or functionality, and modules interact with each other through well-defined interfaces. Clean Architecture can be used to define the structure of the application. Stateless Client-Server Architecture:\nImplement a stateless client-server architecture where the server does not store any client state. Utilize a client-server architectural pattern where the web-based user interface (web browser client) communicates with the server-side components. The client interface allows users to model applications, define business logic, and interact with the platform. The server-side components handle the storage, retrieval, and execution of user-defined models and application logic. Benefits: Separation of concerns, easier user interaction, and centralized management of data and logic. Key Components # Architecture Diagrams # System Context Diagram # Container Diagram # Component Diagram # Deployment Diagram # "}]