<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="System Design # High-level architecture of the low-code platform Explanation of the chosen architectural style Description of the key components and their interactions Detailed design of each microservice and its responsibilities Data model design and database schema High-Level Architecture # Activity Diagram # Architectural Style # Arcchitecture style is the fundamental structural design of a software system. It consists of a set of patterns and principles used to define the system&rsquo;s components, their interactions, and the constraints that guide their design and evolution."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content="System Design # High-level architecture of the low-code platform Explanation of the chosen architectural style Description of the key components and their interactions Detailed design of each microservice and its responsibilities Data model design and database schema High-Level Architecture # Activity Diagram # Architectural Style # Arcchitecture style is the fundamental structural design of a software system. It consists of a set of patterns and principles used to define the system&rsquo;s components, their interactions, and the constraints that guide their design and evolution."><meta property="og:type" content="article"><meta property="og:url" content="http://127.0.0.1:5500/system-design/"><meta property="article:section" content><title>System Design | Project Report</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=stylesheet href=/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz+OQteg=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.7539d2e0ed817069b3f798cbadea524a6d6f759222eecfd2ae053a55b8a38ae7.js integrity="sha256-dTnS4O2BcGmz95jLrepSSm1vdZIi7s/SrgU6Vbijiuc=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Project Report</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/introduction/>Introduction</a></li><li><a href=/literature-review/>Literature Review</a></li><li><a href=/methodology/>Methodology</a></li><li><a href=/project-management/>Project Management</a></li><li><a href=/requirement-analysis/>Requirement Analysis</a></li><li><a href=/system-design/ class=active>System Design</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>System Design</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#system-design>System Design</a><ul><li><a href=#high-level-architecture>High-Level Architecture</a><ul><li><a href=#activity-diagram>Activity Diagram</a></li><li><a href=#architectural-style>Architectural Style</a></li><li><a href=#key-components>Key Components</a></li><li><a href=#architecture-diagrams>Architecture Diagrams</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=system-design>System Design
<a class=anchor href=#system-design>#</a></h1><hr><ul><li><a href=#high-level-architecture>High-level architecture of the low-code platform</a></li><li><a href=#architectural-style>Explanation of the chosen architectural style</a></li><li>Description of the key components and their interactions</li><li>Detailed design of each microservice and its responsibilities</li><li>Data model design and database schema</li></ul><hr><h2 id=high-level-architecture>High-Level Architecture
<a class=anchor href=#high-level-architecture>#</a></h2><h3 id=activity-diagram>Activity Diagram
<a class=anchor href=#activity-diagram>#</a></h3><h3 id=architectural-style>Architectural Style
<a class=anchor href=#architectural-style>#</a></h3><p>Arcchitecture style is the fundamental structural design of a software system. It consists of a set of patterns and principles used to define the system&rsquo;s components, their interactions, and the constraints that guide their design and evolution. <a href=https://en.wikipedia.org/wiki/Software_architecture><sup>1</sup></a></p><h4 id=comparison-of-architectural-styles>Comparison of architectural styles
<a class=anchor href=#comparison-of-architectural-styles>#</a></h4><p><strong>Layered Architecture</strong></p><p>The layered architecture style is a hierarchical design pattern often used in software applications. It breaks apart the application into different functional layers, each providing services to the layer above it <a href=https://www.baeldung.com/cs/layered-architecture><sup>2</sup></a>.</p><p><em>Advantages:</em></p><ul><li>High level of abstraction which simplifies development and maintenance.</li><li>Changes in one layer have minimal impact on other layers, promoting isolation and reducing dependencies.</li><li>Promotes separation of concerns, where each layer focuses on a specific function <a href=https://www.baeldung.com/cs/layered-architecture><sup>3</sup></a>.</li></ul><p><em>Disadvantages:</em></p><ul><li>Overhead and potential performance degradation due to the need for data to pass through multiple layers.</li><li>The design can be rigid and may not be suitable for applications requiring high levels of scalability or flexibility.</li><li>Can lead to &ldquo;fat&rdquo; layers if not carefully managed, where a layer takes on too many responsibilities <a href=https://www.baeldung.com/cs/layered-architecture><sup>4</sup></a>.</li></ul><p><strong>Pipeline Architecture</strong></p><p>Pipeline architecture is a design pattern where data flows through several stages or steps to complete a process. Each stage operates concurrently, and the output of one stage is the input to the next.</p><p><em>Advantages:</em></p><ul><li>Efficient for large volumes of data and complex processing tasks, as data moves through stages concurrently.</li><li>Each stage is independent and can be modified or replaced without affecting others.</li><li>Enables high throughput and processing speed, especially in systems with parallel processing capabilities.</li></ul><p><em>Disadvantages:</em></p><ul><li>Can be complex to design and manage, particularly for complex tasks requiring many stages.</li><li>Performance is limited by the slowest stage in the pipeline.</li><li>If a stage fails, it can disrupt the entire process.</li></ul><p><strong>Microkernel Architecture</strong></p><p>Microkernel architecture is a design pattern where the kernel (core of the operating system) provides only basic services such as inter-process communication, basic scheduling, and basic I/O handling. All other services run as independent processes in user space, communicating with the kernel and each other as necessary <a href=https://www.geeksforgeeks.org/microkernel-in-operating-systems/><sup>5</sup></a>, <a href=https://www.guru99.com/microkernel-in-operating-systems.html><sup>6</sup></a>.</p><p><em>Advantages:</em></p><ul><li>Enhances the reliability and security of the system. If a user-level process fails, it does not affect the kernel or other processes <a href=https://www.linkedin.com/advice/3/what-benefits-drawbacks-using-microkernel-architecture><sup>7</sup></a>.</li><li>Enables modularity and flexibility, as services can be added, removed or replaced without affecting the kernel <a href=https://www.geeksforgeeks.org/microkernel-in-operating-systems/><sup>8</sup></a>.</li></ul><p><em>Disadvantages:</em></p><ul><li>Performance can be slower due to the overhead of inter-process communication.</li><li>The design can lead to increased complexity, making it more challenging to develop and maintain <a href=https://www.linkedin.com/advice/3/what-benefits-drawbacks-using-microkernel-architecture><sup>9</sup></a>.</li></ul><p><strong>Service-Based Architecture</strong></p><p>A Service-Based Architecture (SBA) is a type of architecture where services are the primary architectural components. The services are built on the concept of sharing as much as possible. For example, in a large retail company that has many applications associated with the processing of an order, SOA tries to address this problem through enterprise-level shared services (enterprise services). The Order service is smart enough to know which database to go to retrieve and update order data for each system, at the same time synchronizing the data among all three systems <a href=https://www.oreilly.com/radar/microservices-vs-service-oriented-architecture/><sup>1</sup></a>.</p><p><em>Advantages</em></p><ul><li><strong>Component Sharing</strong>: SBA promotes the sharing of components across the enterprise, increasing scalability and efficiency <a href=https://www.ibm.com/blog/soa-vs-microservices/><sup>1</sup></a>.</li><li><strong>Service Availability and Responsiveness</strong>: SBA addresses service availability (the ability of a remote service to accept requests in a timely manner) and service responsiveness (the ability of the service consumer to receive a timely response from the service) <a href=https://www.oreilly.com/radar/microservices-vs-service-oriented-architecture/><sup>1</sup></a>.</li></ul><p><em>Disadvantages</em></p><ul><li><strong>Complexity</strong>: SBA can be complex and might not be needed for all types of applications. It might be a good choice for larger, more diverse environments but less so for smaller environments like web and mobile applications <a href=https://www.ibm.com/blog/soa-vs-microservices/><sup>1</sup></a>.</li><li><strong>Coordination</strong>: There might be a need for coordination among services to fulfill a single business request, which can increase development, testing, deployment, and maintenance time <a href=https://www.oreilly.com/radar/microservices-vs-service-oriented-architecture/><sup>1</sup></a>.</li></ul><p><strong>Event-Driven Architecture</strong></p><p>Event-Driven Architecture (EDA) uses a publish-subscribe (pub-sub) model, where producers publish events, and consumers subscribe to them. The producers are independent of the consumers, and consumers are independent of each other. It is useful when different subsystems must perform different types of processing on the same event data <a href=https://learn.microsoft.com/en-us/azure/architecture/guide/architecture-styles/><sup>1</sup></a>.</p><p><em>Advantages</em></p><ul><li>Decoupling: In EDA, the producers and consumers are decoupled, which allows them to be scaled, updated, and deployed independently <a href=https://aws.amazon.com/event-driven-architecture/><sup>1</sup></a>.</li><li>Fault Tolerance: Since services are decoupled from each other in EDA, faults are isolated to individual services. If a subscribing service fails, it doesn&rsquo;t impact the service that sent the event. Communications are queued in a broker until the subscriber is repaired or replaced <a href=https://www.techtarget.com/searchapparchitecture/tip/Event-driven-architecture-pros-and-cons-Is-EDA-worth-it><sup>1</sup></a>.</li><li>Real-Time Processing and Responsiveness: EDA enables real-time processing and responsiveness by reacting to events as they occur. It ensures that the system can respond quickly to changes, enabling faster decision-making, real-time analytics, and immediate action <a href=https://www.confluent.io/learn/event-driven-architecture/><sup>1</sup></a>.</li></ul><p><em>Disadvantages</em></p><ul><li>Difficulties with Monitoring: Since the services are independent of each other, you need a proper design to understand how they interact with each other and also a proper alerting mechanism to understand the knock-on effect should a service fail <a href=https://solace.com/blog/event-driven-architecture-pros-and-cons/><sup>1</sup></a></li><li>Complexity: EDA can be complex to implement and manage. It requires a different programming model that may be unfamiliar to developers who are used to request-response models <a href=https://dev.to/aws-builders/event-driven-vs-workflows-a-comprehensive-comparison-for-developers-and-architects-2j9k><sup>1</sup></a>.</li></ul><p><strong>Space-Based Architecture</strong></p><p>Space-Based Architecture (SBA) is a software design approach that organizes the system around the concept of &ldquo;spaces&rdquo;, which are essentially isolated and autonomous units of functionality. Each space has its own data, logic, and interface, and they communicate with each other through message passing<a href=https://dev.to/alexr/software-architecture-patterns-space-based-architecture-h2i><sup>1</sup></a>.</p><p><em>Advantages</em></p><ul><li><strong>Isolation and Autonomy</strong>: SBA promotes a high degree of isolation and autonomy, making it easier to test, deploy, and evolve the system. Since each space is independent, it can be developed, tested, and deployed separately, allowing developers to work on different spaces concurrently <a href=https://dev.to/alexr/software-architecture-patterns-space-based-architecture-h2i><sup>1</sup></a>.</li><li><strong>Scalability and Performance</strong>: SBA allows for easy handling of scalability and performance. Because each space is isolated and can be scaled separately, it allows for better control of the resources used by the system <a href=https://dev.to/alexr/software-architecture-patterns-space-based-architecture-h2i><sup>1</sup></a>.</li></ul><p><em>Disadvantages</em></p><ul><li><strong>Complexity</strong>: SBA requires careful planning and coordination and can add complexity to the system. This complexity can increase the difficulty of development and maintenance <a href=https://dev.to/alexr/software-architecture-patterns-space-based-architecture-h2i><sup>1</sup></a>.</li></ul><p><strong>Microservices Architecture</strong></p><p>A Microservices Architecture is an architectural method that relies on a series of independently deployable services. These services have their own business logic and database with a specific goal. Updating, testing, deployment, and scaling occur within each service. Microservices don&rsquo;t reduce complexity, but they make any complexity visible and more manageable by separating tasks into smaller processes that function independently of each other <a href=https://www.atlassian.com/microservices/microservices-architecture/microservices-vs-monolith><sup>1</sup></a>.</p><p><em>Advantages</em></p><ul><li><strong>Independent Deployment</strong>: Microservices can be deployed independently, allowing developers to update or fix issues in one service without affecting the others <a href=https://www.atlassian.com/microservices/microservices-architecture/microservices-vs-monolith><sup>1</sup></a>.</li><li><strong>Scalability</strong>: Each microservice can be scaled independently based on its specific needs, which leads to better resource utilization <a href=https://stackify.com/6-key-benefits-of-microservices-architecture/><sup>1</sup></a>.</li><li><strong>Technology Diversity</strong>: In a microservices architecture, each service can be built using the technology stack that best suits its requirements. This allows developers to choose the most suitable technologies for each service <a href=https://about.gitlab.com/blog/2022/09/29/what-are-the-benefits-of-a-microservices-architecture/><sup>1</sup></a>.</li></ul><p><em>Disadvantages</em></p><ul><li><strong>Increased Complexity</strong>: Microservices can add increased complexity that leads to development sprawl, or rapid and unmanaged growth. It can be challenging to determine how different components relate to each other <a href=https://www.atlassian.com/microservices/microservices-architecture/microservices-vs-monolith><sup>1</sup></a>.</li><li><strong>Debugging Challenges</strong>: Each microservice has its own set of logs, which makes debugging more complicated. A single business process can run across multiple machines, further complicating debugging <a href=https://www.atlassian.com/microservices/microservices-architecture/microservices-vs-monolith><sup>1</sup></a>.</li></ul><h4 id=chosen-architectural-style>Chosen architectural style
<a class=anchor href=#chosen-architectural-style>#</a></h4><p>For a low-code platform that includes a web-based user interface for modeling applications, defining business logic, and deploying web applications. There are several prolems that need to be addressed:</p><ul><li>Performance: The platform should be able to handle a large number of users and applications.</li><li>Scalability: The platform should be able to scale up and down based on demand since a common runtime environment is used for all applications.</li><li>Many core functionalities:<ul><li>Data Management</li><li>Business Logic Execution</li><li>Application Deployment</li></ul></li></ul><p>Using a <strong>microservices architecture</strong>, we can address these problems by breaking down the platform into smaller, more manageable services. Each service can be developed, tested, and deployed independently, allowing for better control of the resources used by the system. This also allows for easier handling of scalability and performance, as each service can be scaled separately.</p><p>However, this can add more complexity to the development process:</p><ul><li>Communication between services can be challenging to manage.</li><li>It can be challenging to determine how different components relate to each other.</li><li>Each microservice has its own set of logs, which makes debugging more complicated.</li></ul><p>Instead, to better manage the complexity of the system, we can use a <strong>modular monolith architecture</strong>. This architecture allows us to break down the system into smaller modules, each responsible for a specific feature or functionality. These modules can be developed, tested, and deployed independently, allowing for better control of the resources used by the system. This also allows for easier handling of scalability and performance, as each module can be scaled separately.</p><p><strong>Modular Monolith Architecture:</strong><a href=https://shopify.engineering/deconstructing-monolith-designing-software-maximizes-developer-productivity><sup>10</sup></a></p><p><a href=./images/mono-vs-micro.webp><img src=./images/mono-vs-micro.webp alt="Modular Monolith Architecture" width=500></a></p><ul><li>Implement the server-side application as a single unit (monolith), but the codebase is organized into several modules.</li><li>Each module is responsible for a specific feature or functionality, and modules interact with each other through well-defined interfaces.</li><li>Clean Architecture can be used to define the structure of the application.</li></ul><p><strong>Stateless Client-Server Architecture:</strong></p><ul><li>Implement a stateless client-server architecture where the server does not store any client state.</li><li>Utilize a client-server architectural pattern where the web-based user interface (web browser client) communicates with the server-side components.</li><li>The client interface allows users to model applications, define business logic, and interact with the platform.</li><li>The server-side components handle the storage, retrieval, and execution of user-defined models and application logic.</li><li>Benefits: Separation of concerns, easier user interaction, and centralized management of data and logic.</li></ul><h3 id=key-components>Key Components
<a class=anchor href=#key-components>#</a></h3><h3 id=architecture-diagrams>Architecture Diagrams
<a class=anchor href=#architecture-diagrams>#</a></h3><h4 id=system-context-diagram>System Context Diagram
<a class=anchor href=#system-context-diagram>#</a></h4><h4 id=container-diagram>Container Diagram
<a class=anchor href=#container-diagram>#</a></h4><h4 id=component-diagram>Component Diagram
<a class=anchor href=#component-diagram>#</a></h4><h4 id=deployment-diagram>Deployment Diagram
<a class=anchor href=#deployment-diagram>#</a></h4></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#system-design>System Design</a><ul><li><a href=#high-level-architecture>High-Level Architecture</a><ul><li><a href=#activity-diagram>Activity Diagram</a></li><li><a href=#architectural-style>Architectural Style</a></li><li><a href=#key-components>Key Components</a></li><li><a href=#architecture-diagrams>Architecture Diagrams</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>