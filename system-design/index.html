<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="System Design # High-level architecture of the low-code platform Explanation of the chosen architectural style Description of the key components and their interactions Detailed design of each microservice and its responsibilities High-Level Architecture # Architectural Style # Arcchitecture style is the fundamental structural design of a software system. It consists of a set of patterns and principles used to define the system&rsquo;s components, their interactions, and the constraints that guide their design and evolution."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content><meta property="og:description" content="System Design # High-level architecture of the low-code platform Explanation of the chosen architectural style Description of the key components and their interactions Detailed design of each microservice and its responsibilities High-Level Architecture # Architectural Style # Arcchitecture style is the fundamental structural design of a software system. It consists of a set of patterns and principles used to define the system&rsquo;s components, their interactions, and the constraints that guide their design and evolution."><meta property="og:type" content="article"><meta property="og:url" content="https://nguyendhst.github.io/HK231-Specialized-Project/system-design/"><meta property="article:section" content><title>System Design | Project Report</title><link rel=manifest href=https://nguyendhst.github.io/HK231-Specialized-Project/manifest.json><link rel=icon href=https://nguyendhst.github.io/HK231-Specialized-Project/favicon.png><link rel=stylesheet href=https://nguyendhst.github.io/HK231-Specialized-Project/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz+OQteg=" crossorigin=anonymous><script defer src=https://nguyendhst.github.io/HK231-Specialized-Project/flexsearch.min.js></script>
<script defer src=https://nguyendhst.github.io/HK231-Specialized-Project/en.search.min.a752e5e6ce2a7980cdeaebed07045a41652d8c699b5a470b8f313288548f86b6.js integrity="sha256-p1Ll5s4qeYDN6uvtBwRaQWUtjGmbWkcLjzEyiFSPhrY=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=https://nguyendhst.github.io/HK231-Specialized-Project/><span>Project Report</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://nguyendhst.github.io/HK231-Specialized-Project/conclusion/>Conclusion</a></li><li><a href=https://nguyendhst.github.io/HK231-Specialized-Project/introduction/>Introduction</a></li><li><a href=https://nguyendhst.github.io/HK231-Specialized-Project/literature-review/>Literature Review</a></li><li><a href=https://nguyendhst.github.io/HK231-Specialized-Project/methodology/>Methodology</a></li><li><a href=https://nguyendhst.github.io/HK231-Specialized-Project/project-management/>Project Management</a></li><li><a href=https://nguyendhst.github.io/HK231-Specialized-Project/requirement-analysis/>Requirement Analysis</a></li><li><a href=https://nguyendhst.github.io/HK231-Specialized-Project/system-design/ class=active>System Design</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=https://nguyendhst.github.io/HK231-Specialized-Project/svg/menu.svg class=book-icon alt=Menu></label>
<strong>System Design</strong>
<label for=toc-control><img src=https://nguyendhst.github.io/HK231-Specialized-Project/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#system-design>System Design</a><ul><li><a href=#high-level-architecture>High-Level Architecture</a><ul><li><a href=#architectural-style>Architectural Style</a></li></ul></li><li><a href=#architecture-diagrams>Architecture Diagrams</a><ul><li><a href=#key-components>Key Components</a></li><li><a href=#system-context-diagram>System Context Diagram</a></li><li><a href=#container-diagram>Container Diagram</a></li></ul></li><li><a href=#references>References</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=system-design>System Design
<a class=anchor href=#system-design>#</a></h1><hr><ul><li><a href=#high-level-architecture>High-level architecture of the low-code platform</a></li><li><a href=#architectural-style>Explanation of the chosen architectural style</a></li><li><a href=#key-components>Description of the key components and their interactions</a></li><li><a href=#container-diagram>Detailed design of each microservice and its responsibilities</a></li></ul><hr><h2 id=high-level-architecture>High-Level Architecture
<a class=anchor href=#high-level-architecture>#</a></h2><h3 id=architectural-style>Architectural Style
<a class=anchor href=#architectural-style>#</a></h3><p>Arcchitecture style is the fundamental structural design of a software system. It consists of a set of patterns and principles used to define the system&rsquo;s components, their interactions, and the constraints that guide their design and evolution. <a href=https://en.wikipedia.org/wiki/Software_architecture><sup>1</sup></a></p><h4 id=choosing-architectural-styles>Choosing architectural styles
<a class=anchor href=#choosing-architectural-styles>#</a></h4><p>Given the context of developing a low-code platform, some criterias for choosing architectural styles are:</p><ul><li><p><strong>Modularity and Reusability:</strong> The architecture should promote modular design priciples and enabling the development of reusable components/services. The low-code platform includes many core functionalities such as:</p><ul><li>Data Management</li><li>Business Logic Execution</li><li>Application Deployment</li></ul></li><li><p><strong>Scalability:</strong> The architecture should support the platform&rsquo;s ability to serve increasing workloads and user&rsquo;s application requirements. Additional infrastructure resource should be able to horizontally scale to accomodate growth without performance trade-off.</p></li><li><p><strong>User Experience:</strong> The architecture should enable the platform to prioritize providing intuitive user experience. It should promote separation of concerns between the user interface and the server-side logic.</p></li><li><p><strong>Performance and Efficiency:</strong> The architecture should be designed to optimize performance and ensure efficient resource utilization. It should consider factors such as response times, system throughput, data storage, caching mechanisms, and efficient handling of concurrent user interactions.</p></li><li><p><strong>Integration Capabilities:</strong> The architecture should provide seamless integration capabilities with external systems, databases, and services. It should support various integration patterns such as API-based integrations, message queues, or event-driven architectures to enable smooth data exchange and interoperability.</p></li></ul><h4 id=comparison-of-some-candidates>Comparison of some candidates
<a class=anchor href=#comparison-of-some-candidates>#</a></h4><p><strong>Layered Architecture</strong>: Layered architecture, also known as multi-tier architecture, is a software architecture pattern that organizes code into layers where each layer has a specific role and responsibility. This architecture is often used in large-scale applications due to its ability to isolate concerns, enhance maintainability, and support scalability <a href=https://www.outsystems.com/blog/posts/application-architecture/><sup>2</sup></a>.</p><ul><li><strong>Modularity and Reusability:</strong> Layered architecture promotes separation of concerns, which leads to more modular and reusable code.</li><li><strong>Scalability:</strong> Layered architecture supports scalability, particularly vertical scalability. By separating concerns into different layers, we can scale each layer independently based on its specific resource needs. However, horizontal scalability can be challenging with layered architecture, as it requires careful design to ensure stateless behavior and handle distributed data.</li><li><strong>User Experience:</strong> The presentation layer can handles user interface concerns, while business logic and data access are separated into their own layers <a href=https://www.outsystems.com/blog/posts/application-architecture/><sup>3</sup></a>.</li><li><strong>Performance and Efficiency:</strong> Multiple layers can introduce latency due to the overhead of inter-layer communication. This can impact performance and efficiency, particularly for high-throughput or latency-sensitive applications.</li><li><strong>Integration Capabilities:</strong> Layered architecture can support integration with external systems through the use of APIs in the business layer or integration layer. However, development effort can be high for such integration capabilities.</li></ul><p><strong>Event-Driven Architecture</strong></p><p>Event-Driven Architecture (EDA) uses a publish-subscribe (pub-sub) model, where producers publish events, and consumers subscribe to them. The producers are independent of the consumers, and consumers are independent of each other. It is useful when different subsystems must perform different types of processing on the same event data <a href=https://learn.microsoft.com/en-us/azure/architecture/guide/architecture-styles/><sup>4</sup></a>.</p><ul><li><strong>Modularity and Reusability:</strong> EDA supports modular design and reusability. Events can be consumed by multiple services, and each service can process the data separately and apply their individual business logic.</li><li><strong>Scalability:</strong> EDA can improve the scalability of a system. It allows components to communicate asynchronously—producers publish event messages, on their own schedule, without waiting for consumers to receive them <a href=https://aws.amazon.com/what-is/eda/>Source 10</a>.</li><li><strong>User Experience:</strong> EDA can enhance user experience as it allows users to complete a task in one component and move on to the next task without waiting<a href=https://www.ibm.com/topics/event-driven-architecture><sup>5</sup></a>.</li><li><strong>Performance and Efficiency:</strong> EDA can handle a large number of events with low latency. Moreover, with less polling, there is a reduction in network I/O, and decreased costs<a href=https://cloud.google.com/eventarc/docs/event-driven-architectures><sup>6</sup></a>.</li><li><strong>Integration Capabilities</strong>: EDA supports integration capabilities. Event producers are unaware of, unconcerned by, and unburdened by any activity of downstream consumers of the events that they produce <a href=https://aws.amazon.com/what-is/eda/><sup>7</sup></a>.</li></ul><p><strong>Microservices Architecture</strong></p><p>A Microservices Architecture is an architectural method that relies on a series of independently deployable services. These services have their own business logic and database with a specific goal. Updating, testing, deployment, and scaling occur within each service. Microservices don&rsquo;t reduce complexity, but they make any complexity visible and more manageable by separating tasks into smaller processes that function independently of each other <a href=https://www.atlassian.com/microservices/microservices-architecture/microservices-vs-monolith><sup>8</sup></a>.</p><p><em>Advantages</em></p><ul><li><strong>Modularity and Reusability</strong>: MSA supports modularity and reusability. Each microservice is a separate, independently deployable module. Microservices can be reused across different parts of an application or even across different applications <a href=https://www.techtarget.com/searchapparchitecture/tip/The-ups-and-downs-of-low-code-microservices-development><sup>9</sup></a>.</li><li><strong>Scalability</strong>: Each microservice can be scaled independently based on its specific needs, which leads to better resource utilization <a href=https://stackify.com/6-key-benefits-of-microservices-architecture/><sup>10</sup></a>.</li><li><strong>User Experience</strong>: MSA can improve user experience by allowing for faster updates and feature additions. Each microservice can be updated independently without impacting the entire application, enabling quicker adaptations to user feedback and needs <a href=https://www.techtarget.com/searchapparchitecture/tip/The-ups-and-downs-of-low-code-microservices-development><sup>11</sup></a>.</li><li><strong>Performance and Efficiency</strong>: MSA can boost performance and efficiency by allowing each microservice to run its own processes and manage its own database. However, inter-service communication can add latency and complexity, which can impact performance and efficiency <a href=https://learn.microsoft.com/en-us/azure/architecture/microservices/><sup>12</sup></a>.</li><li><strong>Integration Capabilities</strong>: MSA facilitates integration with external systems. Each microservice can expose its own API, allowing for easy integration with other services. However, managing these integrations can be complex <a href=https://www.techtarget.com/searchapparchitecture/tip/The-ups-and-downs-of-low-code-microservices-development><sup>13</sup></a>.</li></ul><p>However, there are some notable disadvantages:</p><ul><li><strong>Increased Complexity</strong>: Microservices can add increased complexity that leads to development sprawl, or rapid and unmanaged growth. It can be challenging to determine how different components relate to each other <a href=https://www.atlassian.com/microservices/microservices-architecture/microservices-vs-monolith><sup>14</sup></a>.</li><li><strong>Debugging Challenges</strong>: Each microservice has its own set of logs, which makes debugging more complicated. A single business process can run across multiple machines, further complicating debugging <a href=https://www.atlassian.com/microservices/microservices-architecture/microservices-vs-monolith><sup>15</sup></a>.</li></ul><p>Using <strong>Microservices architecture</strong> combined with elements from <strong>Event-driven architecture</strong> and <strong>stateless client-server architecture</strong>, the development process can be more efficient by breaking down the platform into smaller, more manageable services. Each service can be developed, tested, and deployed independently, allowing for better control of the resources used by the system. This also allows for easier handling of scalability and performance, as each service can be scaled separately.</p><h2 id=architecture-diagrams>Architecture Diagrams
<a class=anchor href=#architecture-diagrams>#</a></h2><h3 id=key-components>Key Components
<a class=anchor href=#key-components>#</a></h3><ul><li><p><strong>User Management:</strong></p><ul><li><p>This microservice handles user authentication, registration, profile management, and access control.</p></li><li><p>It provides APIs for user-related operations, such as user creation, authentication, and updating user profiles.</p></li></ul></li><li><p><strong>Project Management:</strong></p><ul><li>This microservice is responsible for managing user projects within the platform.</li><li>It handles operations like creating, updating, and deleting projects, as well as retrieving project information.</li><li>It provides APIs for project management, such as project creation, retrieval, and modification.</li></ul></li><li><p><strong>Application Deployment Engine:</strong></p><ul><li>This component focuses on deploying the web applications created by users within the platform.</li><li>It receives the application models, validates them, and handles the deployment process.</li><li>It may interact with other microservices to ensure the availability of necessary resources for the deployed applications.</li></ul></li><li><p><strong>Business Logic Execution Engine:</strong></p><ul><li>This component is responsible for executing the business logic defined by users within their applications.</li><li>It receives the user-defined logic, which can be in the form of scripts, rules, workflows, or other configurations.</li><li>It executes the logic based on the runtime context and provides the necessary data and services to support the execution.</li></ul></li></ul><p>These microservices can communicate with each other using well-defined APIs and protocols, such as RESTful APIs or message queues. The communication can be synchronous or asynchronous, depending on the requirements of the platform.</p><p>By adopting a microservices architecture, the low-code platform can benefit from modularity, scalability, independent development and deployment, and the ability to incorporate new functionalities or services without affecting the entire system.</p><h3 id=system-context-diagram>System Context Diagram
<a class=anchor href=#system-context-diagram>#</a></h3><p><img src=https://nguyendhst.github.io/HK231-Specialized-Project/images/context.svg alt=system-context></p><h3 id=container-diagram>Container Diagram
<a class=anchor href=#container-diagram>#</a></h3><p><img src=https://nguyendhst.github.io/HK231-Specialized-Project/images/container.svg alt=container></p><h2 id=references>References
<a class=anchor href=#references>#</a></h2></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#system-design>System Design</a><ul><li><a href=#high-level-architecture>High-Level Architecture</a><ul><li><a href=#architectural-style>Architectural Style</a></li></ul></li><li><a href=#architecture-diagrams>Architecture Diagrams</a><ul><li><a href=#key-components>Key Components</a></li><li><a href=#system-context-diagram>System Context Diagram</a></li><li><a href=#container-diagram>Container Diagram</a></li></ul></li><li><a href=#references>References</a></li></ul></li></ul></nav></div></aside></main></body></html>