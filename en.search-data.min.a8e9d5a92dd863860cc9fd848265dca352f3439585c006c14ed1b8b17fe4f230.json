[{"id":0,"href":"/conclusion/","title":"Conclusion","section":"","content":" Conclusion # Conclusion about the project What was achieved What can be improved for the capstone project "},{"id":1,"href":"/introduction/","title":"Introduction","section":"","content":" Introduction # Background and motivation for the project Problem statement and objectives Overview of the low-code platform and its significance in supporting the development of a promotion platform Background and Motivation # In an era characterized by digital transformation and rapid technological advances, the demand for software applications is skyrocketing. However, the traditional software development approach often requires a significant investment of time and resources, creating barriers for businesses, especially small to medium-sized enterprises (SMEs), that lack these resources. This challenge is further amplified when businesses need to quickly respond to market changes, such as launching promotional platforms to capitalize on emerging opportunities.\nLow-code platforms have emerged as a promising solution to these challenges. These platforms provide an environment where applications can be developed primarily through graphical user interfaces and configurations, rather than traditional hand-coded programming. By reducing the need for extensive coding, low-code platforms enable quicker and more accessible software development, democratizing application development and empowering a wider range of users.\nProblem Statement and Objectives # Despite the potential of low-code platforms, their adoption for specific use-cases such as promotional platforms remains limited. This limitation arises partly due to a lack of understanding and partly due to the perceived inflexibility of such platforms for specialized applications. Therefore, there is a need to explore the capabilities of low-code platforms in the context of developing promotional platforms and to mitigate existing limitations.\nThe objective of this project is to develop a low-code platform that can effectively support the development of promotional platforms. Our goals include:\nAnalyzing the specific requirements for promotional platforms. Designing a low-code platform that caters to these requirements. Implementing and testing the designed low-code platform. Demonstrating the effectiveness of the low-code platform on developing a promotional platform. Overview and Significance # Our proposed low-code platform will incorporate a user-friendly interface for designing the layout and workflow of the promotional platform, a code generator for translating the design into executable code, and a compiler for building and deploying the application. The platform will support the customization required for promotional platforms, such as user management, product management, discount management, and analytics.\nThis project holds significant implications for both academia and industry. For academia, it provides an opportunity to explore the intersection of low-code platforms and promotional platforms, contributing to the body of knowledge in software engineering and digital marketing. For industry, particularly for SMEs, this platform could drastically reduce the time, cost, and complexity of developing promotional platforms, thereby enhancing their competitiveness in the market. Furthermore, the low-code approach could potentially allow non-technical staff, such as marketers, to participate in the development process, fostering cross-functional collaboration and innovation.\n"},{"id":2,"href":"/literature-review/","title":"Literature Review","section":"","content":" Literature Review # Review of existing low-code platforms and their features Exploration of related technologies and frameworks Analysis of similar projects or research in the field "},{"id":3,"href":"/methodology/","title":"Methodology","section":"","content":" Methodology # Description of the development methodology employed Overview of the technologies, tools, and frameworks used Development Methodology # Development Approach Task Management Version Control Developement Approach # The project\u0026rsquo;s development approach is based on the Agile methodology, but does not follow strictly to any existing framework. Some of the main principles of the Agile methodology that will be followed are:\nEach team member shares the same responsibilities and has the same authority. The team is self-organizing and self-managing. The team is cross-functional and has all the skills necessary to complete the project. The team is self-sufficient and does not rely on external resources. The project will be divided into multiple iterations, which will have a duration of 1 week. Each iteration will have a set of tasks to be completed, and at the end of each iteration, the team will deliver a working product increment. The product increment will be reviewed and evaluated by the team and the advisors, and the feedback will be used to improve the product in the next iteration.\nTask Management # Task management is done using GitHub Projects. The project is divided into multiple iterations, each of which is represented by a GitHub Project board. Each iteration board is divided into 4 columns: To do, In progress, Review, and Done. Each task is represented by a GitHub Issue, which is then added to the corresponding column on the board. The team members will then move the tasks between the columns as they progress through the iteration.\nProject Planning and Scheduling # Project Timeline # The project begins from 11/09/2023 and is expect to lasts 15 weeks until 19/12/2023.\nTwo major milestones are set for the project:\nPrototype release: 08/10/2023\nThe prototype release is the first release showcasing key features of the project. The prototype release will include: A web application that allows users to create and manage their projects. Visual DnD Editor that allows users to visually model their projects. Version 0.1.0 release: 05/11/2023\nThe version 0.1.0 release is the first release of the project that can be evaluated by users. The version 0.1 release will include: Fully functional visual DnD editor. Workflow UI that allows users to create and manage their workflows. Application deployment to a cloud service provider. User authentication and authorization. MVP release: 11/12/2023\nThe MVP release is the final release of the project. The MVP release will include: Fully functional visual DnD editor. Workflow DnD Editor that allows users to visually model their workflows. Business Logic Execution Engine that allows users to execute their workflows. gantt dateFormat YYYY-MM-DD title Project Timeline axisFormat %m/%d section Requirement Analysis Requirement Analysis: 2023-08-28, 2023-09-11 section System Design System Design: 2023-09-11, 2023-09-26 section Implementation Implementation: 2023-09-26, 2023-12-10 v0.0.1 Prototype Release: milestone, 2023-10-08, 0d Version v0.1.0: milestone, 2023-11-05, 0d MVP Release: milestone, 2023-12-11, 0d section Documentation Requirment Analysis: 2023-08-28, 2023-09-11 System Design: 2023-09-11, 2023-09-26 Technical Documentation: 2023-09-26, 2023-12-03 Concluding Report: 2023-12-03, 2023-12-10 Version Control # Version control of the project is done using Git and GitHub. The project repository is hosted on GitHub and is accessible at link.\nTo work on the project, a Git branching model convention is used. The model is as follows:\n%%{init: { 'logLevel': 'debug', 'theme': 'base', 'gitGraph': {'showBranches': true, 'showCommitLabel':true,'mainBranchOrder': 1}} }%% gitGraph LR: commit branch dev order: 1 branch feature/1 order: 2 commit commit checkout dev merge feature/1 checkout main branch feature/2 order: 3 commit commit merge feature/1 checkout dev merge feature/2 checkout main merge dev branch hotfix order: 0 commit commit checkout main merge hotfix Main branch: main - The main branch is the branch where the source code of HEAD always reflects a production-ready state.\nDevelopment branch: dev - The development branch is the branch where the source code of HEAD always reflects a state with the latest delivered development changes for the next release. Some would call this the “integration branch”. This is where any automatic nightly builds are built from.\nFeature branch: feature/1 - Feature branches (or sometimes called topic branches) are used to develop new features for the upcoming or a distant future release. When starting development of a feature, the target release in which this feature will be incorporated may well be unknown at that point. The essence of a feature branch is that it exists as long as the feature is in development, but will eventually be merged back into develop (to definitely add the new feature to the upcoming release) or discarded (in case of a disappointing experiment).\nHotfix branch: hotfix - Hotfix branches are very much like release branches in that they are also meant to prepare for a new production release, albeit unplanned. They arise from the necessity to act immediately upon an undesired state of a live production version. When a critical bug in a production version must be resolved immediately, a hotfix branch may be branched off from the corresponding tag on the master branch that marks the production version.\nTechnologies, Tools, and Frameworks # "},{"id":4,"href":"/project-management/","title":"Project Management","section":"","content":" Project Management # Overview of project planning and scheduling Discussion of project milestones and deliverables Reflection on team collaboration and coordination Lessons learned and recommendations for future projects Project Planning and Scheduling # Project Timeline # The project begins from 11/09/2023 and is expect to lasts 15 weeks until 19/12/2023. The project is divided into 3 phases, each of which lasts 5 weeks. The phases are as follows:\nPhase 1: Requirement Analysis Phase 2: System Design Phase 3: Implementation Phase 4: Testing and Deployment Two major milestones are set for the project:\nFirst release: 01/10/2023 MVP release: 11/12/2023 gantt dateFormat YYYY-MM-DD title Project Timeline axisFormat %m/%d section Requirement Analysis Requirement Analysis: 2023-08-28, 2023-09-11 section System Design System Design: 2023-09-11, 2023-09-18 section Implementation Implementation: 2023-09-18, 2023-12-10 section Testing and Deployment Testing and Deployment: 2023-12-10, 2023-12-17 Project Milestones and Deliverables # Team Collaboration and Coordination # Lessons Learned and Recommendations # "},{"id":5,"href":"/requirement-analysis/","title":"Requirement Analysis","section":"","content":" Requirement Analysis # Identification and documentation of functional and non-functional requirements Use cases and user stories for the low-code platform Discussion of expectations and limitations of the project Actor # Developer: include citizen developers and technical developers who create application by platform Example: developers, system engineers, business employees in different departments like sales, marketing, etc. External database, CMS Third-party Provider Requirements # Functional requirements # For Developer (User) # The platform provides lowcode UI or drag-n-drop interface for users to interact with when editing or customizing\nAuthentication\nSign up by third-party provider Sign in by third-party provider Manage Project\nCreate a project to generate an application from blank or templates Edit Project Customize provided components by lowcode UI or Js code Search components Invite a collaborator to join editing project Find Project by name or filter projects created Delete projects Manage Datasource\nDoing CRUD with table (database) provided by platform Connect to external datasource to create data table and map data Deploy Application\nCreate versions of projects and applications by savepoints functionality Using preview mode to display and check their applications and workflows Deploy an application onto server from projects Manage Business Process\nCreate a business process with business logics Edit an existing business process Add business process to application Create a business logic Customize a provided business logic Optional - Functionality can be considered updating in future\nBe supported stages of project development: Develop, Staging, Production Manage account information: change password, profile, etc. Debug an application - track execution of application Create project templates Create business process templates Track changes to the projects over time Non-functional requirements # Non-Requirements Details Metrics Performance The platform must be able to handle a large number of concurrent users without any performance degradation Response time \u0026lt; 2 second for 100 concurrent users Reliability The downtime percentage of platform should remain low The downtime percentage remain under 2% and the probability encountering errors of users is under 5% a month Security Platform protects user data and datasource from unauthorized access, modification, destruction Role-based access control, data encryption, and auditing. Localization Platform supports multi-language Vietnamese and English Usability Easy to use, Good UI Platform allows non-technical users to get up and running with under 30 minutes learning Usecase # Usecase Diagram # Usecase Diagram\nUsecase Scenario # Sign in # Usecase Sign-in Actor User (Nontechnical or technical user) Description User logs in into account created to use the platform Trigger User accesses the platform\u0026rsquo;s link Pre-condition User has internet access Platform is working normally Post-condition User logs in successfully into platform Normal Flow 1. User clicks the third provider icon 2. System redirects to the authentication page of the third provider 3. User provides authentication information 4. Third provider checks information received and allow access 5. System takes information for checking and redirect to main workspace page Usecase ends Alternative Flow None Exception Flow 3.1 System sends notification that the information provided is wrong or not existed 3.2 User chooses login again Usecase continues at step1 3.2.1 User cancels the sign in phase Usecase ends Edit project # Customize a component # Usecase Customize a component in project Actor User (Nontechnical or technical user) Description User customizes the provided component to use in project Trigger User clicks a component in the canvas Pre-condition User is in editor of a project Post-condition Component is updated in project based on user config Normal Flow 1. User chooses what to config in customize tab: color, name, event, \u0026hellip; 2. System changes to config view of each type 3. User customizes the component through a click-based UI and click \u0026lsquo;Save\u0026rsquo; 4. System updates the component UI based on configuration and modifies the main canvas Usecase ends Alternative Flow 3.1 User can use code-based config by JS, \u0026hellip; and click \u0026lsquo;Save\u0026rsquo; Usecase continues at step 4 Exception Flow None Create and Edit business process # Usecase Create and Edit a business process to apply in application Actor User (Nontechnical or technical user) Description User defines and applies business process into the product Trigger User clicks \u0026lsquo;Add business process\u0026rsquo; in Customize Tab when customize component User clicks a business process in business customize tab in workspace Pre-condition User logged in and in customize view or in main workspace Post-condition Business process is created and added by system Normal Flow 1. User clicks a blank business process or an existing business process 2. System brings user to another drag-n-drop edit view. 3. User chooses provided components/node about business logic and drag-n-drop into the dashboard 4. User click \u0026lsquo;save\u0026rsquo; button 5. System updates and saves the changes Usecase ends Alternative Flow 5.1 If user triggers in customize view, system adds the business process to targeted component. Usecase ends At step 4: 4.1 User doesn\u0026rsquo;t click save button, but closes the edit view 4.2 System shows modal to make sure user\u0026rsquo;s choice and whether to save the business project 4.3 User chooses \u0026lsquo;Save\u0026rsquo; button 4.4 System saves the updated business process Usecase ends At step 4.3: 4.3.1 User clicks \u0026lsquo;Cancel\u0026rsquo; Usecase continues at step 3 4.3.a User clicks \u0026lsquo;Don\u0026rsquo;t save\u0026rsquo; 4.3.b System keeps the previous version of project Usecase ends Exception Flow None Create data table # Usecase Create data table Actor User (Nontechnical or technical user) Description User creates data model or data table for use Trigger User clicks \u0026ldquo;Add Datasource\u0026rdquo; in the panel Pre-condition User has logged in into platform Post-condition System can access to data source and can CRUD data to destination (data entities) based on authority allowed Normal Flow 1. User click \u0026ldquo;Database\u0026rdquo; in the right toolbar then click \u0026ldquo;Add\u0026rdquo; button 2. System shows the modal for user to choose 3. User chooses the database and provides configuration about access and authority 4. System connects to database and retrieve data 5. System renders the data into table views with column, options box that user can interact with to view or edit model or CRUD request Usecase ends Alternative Flow None Exception Flow None Deploy an application # Usecase Generate an runnable application Actor User (Nontechnical or technical user) Description From the preview mode of the product, user can decide to deploy it Trigger Click the deploy button when user is in preview mode Pre-condition User has a ready application stored in platform User is the owner of the application Post-condition System deploys the application on to server Normal Flow 1. In the view in preview mode, user click \u0026lsquo;deploy\u0026rsquo; button 2. System shows up a config view for user 3. User inputs description 4. System prepares the app and deploy it onto server 5. System opens the application in the new window Usecase ends Alternative Flow None Exception Flow None "},{"id":6,"href":"/system-design/","title":"System Design","section":"","content":" System Design # High-level architecture of the low-code platform Explanation of the chosen architectural style Description of the key components and their interactions Detailed design of each microservice and its responsibilities High-Level Architecture # Architectural Style # Arcchitecture style is the fundamental structural design of a software system. It consists of a set of patterns and principles used to define the system\u0026rsquo;s components, their interactions, and the constraints that guide their design and evolution. 1\nChoosing architectural styles # Given the context of developing a low-code platform, some criterias for choosing architectural styles are:\nModularity and Reusability: The architecture should promote modular design priciples and enabling the development of reusable components/services. The low-code platform includes many core functionalities such as:\nData Management Business Logic Execution Application Deployment Scalability: The architecture should support the platform\u0026rsquo;s ability to serve increasing workloads and user\u0026rsquo;s application requirements. Additional infrastructure resource should be able to horizontally scale to accomodate growth without performance trade-off.\nUser Experience: The architecture should enable the platform to prioritize providing intuitive user experience. It should promote separation of concerns between the user interface and the server-side logic.\nPerformance and Efficiency: The architecture should be designed to optimize performance and ensure efficient resource utilization. It should consider factors such as response times, system throughput, data storage, caching mechanisms, and efficient handling of concurrent user interactions.\nIntegration Capabilities: The architecture should provide seamless integration capabilities with external systems, databases, and services. It should support various integration patterns such as API-based integrations, message queues, or event-driven architectures to enable smooth data exchange and interoperability.\nComparison of some candidates # Layered Architecture: Layered architecture, also known as multi-tier architecture, is a software architecture pattern that organizes code into layers where each layer has a specific role and responsibility. This architecture is often used in large-scale applications due to its ability to isolate concerns, enhance maintainability, and support scalability 2.\nModularity and Reusability: Layered architecture promotes separation of concerns, which leads to more modular and reusable code. Scalability: Layered architecture supports scalability, particularly vertical scalability. By separating concerns into different layers, we can scale each layer independently based on its specific resource needs. However, horizontal scalability can be challenging with layered architecture, as it requires careful design to ensure stateless behavior and handle distributed data. User Experience: The presentation layer can handles user interface concerns, while business logic and data access are separated into their own layers 3. Performance and Efficiency: Multiple layers can introduce latency due to the overhead of inter-layer communication. This can impact performance and efficiency, particularly for high-throughput or latency-sensitive applications. Integration Capabilities: Layered architecture can support integration with external systems through the use of APIs in the business layer or integration layer. However, development effort can be high for such integration capabilities. Event-Driven Architecture\nEvent-Driven Architecture (EDA) uses a publish-subscribe (pub-sub) model, where producers publish events, and consumers subscribe to them. The producers are independent of the consumers, and consumers are independent of each other. It is useful when different subsystems must perform different types of processing on the same event data 4.\nModularity and Reusability: EDA supports modular design and reusability. Events can be consumed by multiple services, and each service can process the data separately and apply their individual business logic. Scalability: EDA can improve the scalability of a system. It allows components to communicate asynchronously—producers publish event messages, on their own schedule, without waiting for consumers to receive them Source 10. User Experience: EDA can enhance user experience as it allows users to complete a task in one component and move on to the next task without waiting5. Performance and Efficiency: EDA can handle a large number of events with low latency. Moreover, with less polling, there is a reduction in network I/O, and decreased costs6. Integration Capabilities: EDA supports integration capabilities. Event producers are unaware of, unconcerned by, and unburdened by any activity of downstream consumers of the events that they produce 7. Microservices Architecture\nA Microservices Architecture is an architectural method that relies on a series of independently deployable services. These services have their own business logic and database with a specific goal. Updating, testing, deployment, and scaling occur within each service. Microservices don\u0026rsquo;t reduce complexity, but they make any complexity visible and more manageable by separating tasks into smaller processes that function independently of each other 8.\nAdvantages\nModularity and Reusability: MSA supports modularity and reusability. Each microservice is a separate, independently deployable module. Microservices can be reused across different parts of an application or even across different applications 9. Scalability: Each microservice can be scaled independently based on its specific needs, which leads to better resource utilization 10. User Experience: MSA can improve user experience by allowing for faster updates and feature additions. Each microservice can be updated independently without impacting the entire application, enabling quicker adaptations to user feedback and needs 11. Performance and Efficiency: MSA can boost performance and efficiency by allowing each microservice to run its own processes and manage its own database. However, inter-service communication can add latency and complexity, which can impact performance and efficiency 12. Integration Capabilities: MSA facilitates integration with external systems. Each microservice can expose its own API, allowing for easy integration with other services. However, managing these integrations can be complex 13. However, there are some notable disadvantages:\nIncreased Complexity: Microservices can add increased complexity that leads to development sprawl, or rapid and unmanaged growth. It can be challenging to determine how different components relate to each other 14. Debugging Challenges: Each microservice has its own set of logs, which makes debugging more complicated. A single business process can run across multiple machines, further complicating debugging 15. Using Microservices architecture combined with elements from Event-driven architecture and stateless client-server architecture, the development process can be more efficient by breaking down the platform into smaller, more manageable services. Each service can be developed, tested, and deployed independently, allowing for better control of the resources used by the system. This also allows for easier handling of scalability and performance, as each service can be scaled separately.\nArchitecture Diagrams # Key Components # User Management:\nThis microservice handles user authentication, registration, profile management, and access control.\nIt provides APIs for user-related operations, such as user creation, authentication, and updating user profiles.\nProject Management:\nThis microservice is responsible for managing user projects within the platform. It handles operations like creating, updating, and deleting projects, as well as retrieving project information. It provides APIs for project management, such as project creation, retrieval, and modification. Application Deployment Engine:\nThis component focuses on deploying the web applications created by users within the platform. It receives the application models, validates them, and handles the deployment process. It may interact with other microservices to ensure the availability of necessary resources for the deployed applications. Business Logic Execution Engine:\nThis component is responsible for executing the business logic defined by users within their applications. It receives the user-defined logic, which can be in the form of scripts, rules, workflows, or other configurations. It executes the logic based on the runtime context and provides the necessary data and services to support the execution. These microservices can communicate with each other using well-defined APIs and protocols, such as RESTful APIs or message queues. The communication can be synchronous or asynchronous, depending on the requirements of the platform.\nBy adopting a microservices architecture, the low-code platform can benefit from modularity, scalability, independent development and deployment, and the ability to incorporate new functionalities or services without affecting the entire system.\nSystem Context Diagram # Container Diagram # References # "}]